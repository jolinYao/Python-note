# Python 学习

## python入门

### 打印hello world

### 什么是编程语言

- 人类和计算机交流的语言

### 什么是解释器

- 将python代码解释为计算机可以识别的二进制

### 什么是.py文件

## python语法表达

### 字面量

- 在代码中固定的值

### 注释

- 不会影响函数的运行

- 分为多行注释、单行注释

	- 单行注释：#

	- 多行注释：""" """

### 变量

- 存储计算结果以及表示值

- 变量名称=变量值

- 记录变量是为了重复应用

### 数据类型

- string

	- 字符串

- int

	- 整型

- float

	- 浮点数

- 可以用type（）函数，检测数据类型

### 数据类型转换

- int()

- float()

- string()

- 任何类型都可转化为字符串类型

- 浮点数和整数之间也可以互相转化，但是浮点数转化为整数会丢失部分精度

### 标识符

- 变量、函数、类、方法的命名，称之为标识符

- 标识符可以由英文、数字、下划线组成，一般不用中文

- 标识符首字母不可以为数字

- 标识符大小写敏感

- 标识符不可以为关键字

### 运算符

- 基础运算符

	- 加、减、乘、除、整除、取余、指数

- 赋值运算符

	- +=、-+.......

### 字符串拼接与格式化

- 占位型拼接格式化

	- %s 将内容转化为字符串，放入占入位置

	- %d 将内容转化为整数，放入占入位置

	- %f 将内容转化为浮点数，放入占入位置

		- 格式化精度控制

			- %m.nd(f)表示；其中m表示数字宽度，如果m小于数字长度本身，m没有意义，如果m大于数字，会在数字前面加空格补齐；其中n用来控制小数点后精度，会进行四舍五入

- 快速格式化

	- f"内容{变量}"

### 数据输入

- input()函数

- 数据输入默认储存为string类型

## python判断语句

### 布尔类型

- ture为1，false为假

- 可以通过比较运算得到布尔类型

### if语句基本格式

- 判断条件后面需要加冒号：

- python通过缩进判断归属，所以在if判断条件之后需要添加缩进

- 只有判断条件为true才会进入if内部代码

### if/else组合判断

- else一定与if组合使用

- else后面也需要加冒号：

### if/elif/else语句

- 有时候判断条件不止一个，所以加入elif可以多重判断

- 判断是有互斥且有顺序的

- 如果满足条件1，那么将不会进入条件2、3.。。

- 如果if和elif条件均不满足，则会进入else

### 判断语句嵌套

- 很多条件并不是并列条件，会出现满足前置条件才会二次判断的多层判断需求

- 嵌套的关键点在于空格缩进

## python循环语句

### while循环

- 满足while条件时，会无限循环执行

- ⚠️注意结束条件

- while嵌套语句：在外层while循环内再写一个内层的while循环

### for循环

- for循环也叫遍历循环，只能从被处理数据集中，依次取出内容进行处理

	- 被处理数据集可以是：字符串、列表、元组等

	- range()语句可以获得一个简单的数字序列

		- range(a)

		- range(a,b)

		- range(a,b,c)

- for循环嵌套使用

### break&contiune

- contiune

	- 暂时跳过本循环，直接进入下一次循环

	- 在嵌套使用时，它只会影响内层循环

- break

	- 会直接结束循环

	- 在嵌套使用时，它只会影响内层循环

## python中的函数

### 函数：组织好的，可以重复使用的，用来实现特定功能的代码段

### 函数的定义

- def 函数名（传入函数）：

### 函数的传入参数

- 形式参数

- 实际参数

### 函数的返回值

- return 返回值

- 函数遇到return之后就结束了，写在return之后的代码不会运行

- 返回值none

	- 布尔类型属于false

	- 常应用于返回值以及if判断

- 函数多返回值

	- 当一个函数，存在两个return

	- 原因因为return可以退出当前函数，导致return下方的代码不执行

### 函数嵌套使用

- 一个函数里面又调用了另外一个函数

### 变量作用域

- 局部变量

	- 函数内部的变量

- 全局变量

	- 函数体内部外部，都能生效的变量（在函数体外部定义）

- 在函数内修改全局变量

	- 函数内定义 global 变量名

### 参数形式

- 位置参数

	- 根据函数定义的参数位置来传递参数

	- 传递参数位置和定义参数顺序需要一致

- 关键字参数

	- “键=值”的形式传递参数，不需要前后顺序

	- 位置参数，需要在关键字参数之前

- 缺省参数

	- 也叫默认值参数，在函数定义的时候就已经定义好了

	- def user_info(name,age,gender='male'):

		- 如果后面函数调用，没有定义gender，那么gender默认为male

- 不定长参数

	- 也叫可变参数，不确定调用的时候会传递多少个参数

	- 位置传递

		- def user_info(*args):

		- 传入的所有参数都会被收集，它会根据参数的位置合并为一个元组(tuple)

	- 关键字传递

		- def user_info(**args):

		- 参数时“键=值”形式的情况下，所有键值都会被接受，会依次形成字典

### 匿名函数

- 函数作为参数传递，是一种计算逻辑传递，而不是数据传递

- lambda定义匿名函数（无名称）

	- 有名称的函数，可以基于名称重复使用

	- lambda函数只能使用一次

- lambda 传入函数：函数体（一行代码）

- lambda x,y:x+y

## 数据容器

### 列表

- 变量名称=[元素1，元素2，元素3.....]

- 列表可以存储多种数据

- 可以支撑不同数据类型

- 支持嵌套

	- list_2[2][0] 取出嵌套值

- 可以修改

- 允许可重复数据存在

- 使用方法

	- 下标索引：列表[下标索引]

		- 从列表中取出元素

		- list_2[-1] 倒序输出

	- 查找某元素下标：列表.index(元素)

	- 更改特定元素值：列表[下标]=值

	- 插入元素：列表.insert(下标，元素)

	- 追加元素

		- 尾部追加一个元素

			- 列表.append（元素）

		- 尾部增加多个元素

			- 列表.extend(其他数据容器)

	- 删除元素

		- 指定下标

			- `del列表[下标]`

			- 列表.pop(下标)

				- pop本质上是将元素取出来，然后返回回去，我们可以得到一个返回值，元素也会从列表中删除

		- 指定内容

			- `列表.remove(元素)`

				- 删除某个元素在列表中的第一个匹配项（并不会删去全部匹配项）

	- 清空列表

		- 列表.clear()

	- 统计某个元素在列表中的数量

		- `列表.count(元素)`

	- 统计列表中全部元素数量（列表长度）

		- len（列表）

- 列表循环

	- while循环

		- while index<len(mylist):

	- for循环

		- for i in mylist:

### 元组

- 存储多个元素、不同类型

- 元组一旦形成，不可修改

	- 但是如果元组里面有一个list，那么元组是可以被修改的

- 变量名称=(元素1，元素2，元素3，元素4....)

	- 如果元组中只有一个数据，这个数据后面需要添加逗号

- 元组的嵌套及读取

	- t1=((1,2,3),(1,3,4))

	- print(t1[1][2])

- 使用方法

	- 查找下标元素

		- 元组.index(元素)

	- 统计某个元素在元组中的数量

		- t1.count(2)

	- 统计元组长度

		- len()

- 元组遍历

	- while

		- while index<len(t1):

	- for

		- for i in t1:

### 字符串

- 字符串也是无法修改数据，只能存储为新的字符串

- 字符串可以对下标进行访问

	- value1=my_str[-2]

- 使用方法

	- 查找特定字符串下标：字符串.index(字符串)

	- 字符串替换

		- 字符串.replace(字符串1,字符串2)

		- 修改的不是字符串本身，而是得到一个新的字符串

	- 字符串分割

		- 字符串.split(分隔字符串)

		- 按照分割字符串，将字符串划分为多个字符串，并存入列表对象

	- 字符串规整操作

		- 去除前后空格

			- 字符串.strip()

		- 去除前后指定字符串

			- 字符串.strip(字符串)

	- 计算字符串出现的次数

		- `字符串.count()`

	- 字符串长度

		- `字符串.count()`

- 字符串大小比较

	- 通过ASCII码值进行比较

	- 按位比较

		- 一位一位比，只要哪一位大，那么整体就大

		- eg.abd>abc;ab>a

### 序列

- 序列是指，内容连续、有序，可以使用下标引索的一类容器

- 序列切片语法

	- 序列[起始下标：结束下标：步长]

	- 起始下标：子序列从何处开始

		- 留空，表示从头开始

	- 结束下标：子序列从何处结束

		- 子序列不包含结束位置下标，留空表示截取到结尾

	- 步长：取元素的间隔，可以为正，也可以为负（为负表示，从后往前取）

	- 对序列切片并不会影响序列本身，而是会得到一个新的序列

### 集合

- 不支持重复元素，且内部无序

	- 不支持下标索引，但是支持修改

- 使用方法

	- 添加元素

		- `集合.add(元素)`

	- 移除元素

		- `集合.remove(元素)`

	- 集合中随机取出一个元素

		- 集合.pop()

		- 会有一个元素从集合中取出来，同时集合本身被修改，元素被移除

	- 清空集合

		- my_set.clear()

	- 取两个集合差集

		- 集合1.difference(集合2)

			- 取出集合1有，而集合2没有的，得到一个新集合

	- 消除差集

		- 集合1.difference_updata(集合2）

			- 对比集合1和集合2，在集合1内，删除和集合2相同的元素

			- 集合1被修改，集合2不变

	- 两个集合合并

		- 集合1.union(集合)

			- 将集合1和集合2合成新集合

	- 统计集合元素数量

		- len()

- 集合遍历

	- 集合只支持for循环遍历

		- for element in set3:

### 字典

- 字典的定义

	- my_dict={key:value,key:value,ley:value....}

- 字典中的key是不可以重复的

	- 如果重复，同一个key，后定义的value会覆盖之前的value

- 基于key获得value

	- score=my_dist["xiaohua"] # 直接搜索key就好，会有匹配到value

- 字典的嵌套

	- score_dist={"jack":{"chinese":77,"math":66,"English":33},
            "Mark":{"chinese":88,"math":86,"English":55},
            "jolin":{"chinese":99,"math":96,"English":66}}

- 操作方法

	- 新增元素

		- 字典[key]=value

			- 字典被修改，新增元素

	- 更新元素

		- 字典[key]=value

			- 元素被更新

	- 删除元素

		- 字典.pop(key)

			- 指定key的数据被删除

	- 清空字典

		- 字典.clear()

			- 字典被清空

	- 获得全部的key

- 遍历字典

	- 不支持while循环遍历

	- 通过获得全部的key来完成循环

		- keys=score_dist.keys()
for key in keys:

	- 直接用for循环，每一次循环都是直接得到key

		- for key in score_dist:

### 总结：

- 列表

	- 支持多个元素，且元素类型任意，支持下标检索，元素可重复，元素可修改，是有序数据

		- 可修改、可重复的一批数据记录场景

- 元组

	- 支持多个元素，且元素类型任意，支持下标检索，元素可重复，元素不可修改，是有序数据

		- 不可修改、可重复的一批数据记录场景

- 字符串

	- 仅支持字符，且不支持修改，若修改则生成新发字符串

		- 一串字符串的记录场景

- 集合

	- 支持多个元素，元素可以为任意类型，但是不支持下标索引，也不支持重复元素，不是有序数据，支持修改

		- 不可重复的数据记录场景

- 字典

	- key：value，key除字典以外任意类型，value任意类型，不支持下标索引，不支持重复元素，数据无序

		- 以key检索value的数据记录场景

## python文本

### 打开文件

- open()函数打开一个已经存在的文件

- open(name,mode,encoding)

	- Name: 要打开文件名的字符串

	- mode：设置打开文件的模式（只读、写入、追加）

	- encoding：编码格式

	- f=open('python.txt','r',encoding=UTF-8) # 要使用关键字传参

### 读取文件

- read()函数

- f.read(5) 读5个字节

- f.read() 读取全部字节

- f.readlines() 读取全部行，然后封装到列表中

- f.readline() 一次读一行

- 注意⚠️：当代码里面多次read文件时，第一次后面的read不会从头开始，而是会接着读取

### 写入文件

- f=open('python.txt','w')
f.write("hello world")
f.flush

	- 直接调用write，内容并不会真正写入文件，而是会积攒在缓冲区；只有调用flush的时候，内容才会写入文件

	- 注意⚠️：w模式，文件不存在，会创建新文件；w模式，文件存在，会清空原有内容

### 追加文件

- f=open('python.txt','a')
f.write("hello world")
f.flush

	- 注意⚠️：a模式，文件不存在，会创建新文件；a模式，文件存在会追加写入文件

### 关闭文件

- f.close()

- 文件如果不关闭，文件会被程序占用

- 另外一种方法：with open('python.txt','w',encoding="UTF-8")as f:

## python异常

### 当检测到一个错误时，python解释器无法继续执行——异常（Bug）

### 捕获异常：提前假设某处会出现异常

- try:
     可能发生错误的代码
except：
      如果出现异常，执行代码

### 捕获多个异常

- except (NameError,ZeroDivisionError)as e:

### 捕获所有异常

- `except:` 和 `except Exception as e:` 都是捕获全部异常

## python模块

### 什么是python模块

- 模块是一个python文件，模块内含可执行代码，可以认为模块是一个工具包

### 导入方式

- import 模块名
import 模块名1，模块名2
模块名.功能名()

### 自定义模块

- 新建一个python文件

- 在需要使用的时候直接import就好

	- import my_module1

my_module1.test(1,2) # 自己在另外一个文件里面

### 重名函数

- 如果两个模块名称相同，那么后调用的函数将覆盖之前调用的函数

### 测试函数

- 只在当前文件中调用，其他文件导入时，不会被直接输出

	- if __name__ =="__main__":
  test(1,1)

### ——all——变量

- 如果文件中有"--all--"变量，当使用`'from xxx import *'`导入时，只会导入列表中的函数

	- __all__=['test1']
def test(a,b):
    print(a+b)
def test1(a,b):
    print(a-b)

	- 导入这个的时候就只会导入test1函数

## python包

### python包可以看成是一个文件夹，`__init.py__`存在在文件夹里面的话就是python包，如果没有就算普通文件夹

### 导入方法

- import my_package.my_module1
my_package.my_module1.infp_print1()

- from my_package import my_module1
my_module1.infp_print1()

- from my_package.my_module1 import infp_print1
infp_print1()

- 在__init.py__文件中添加"--all--=[]",控制允许导入的模块列表

	- __all__=["my_module2"]

from my_package import *
my_module2.info_print2()

### 安装第三方包

- 使用python内置的pip程序

## 类

### 初识对象

- 设计class类-创建对象-对象属性赋值

### 类的定义和使用

- class关键字，定义类的属性（变量），类的行为（方法）

- 创建类的语法： 对象=类名称（）

- 成员方法：def 方法名（self，形参1，形参2...) ;注意一定要有self

	- self关键字虽然在列表中，但是在传参的时候可以忽略

### 类和对象

- 设计类，基于类设计对象，再由对象完成具体工作

	- class Clock:
    id=None
    price=None

    def ring(self):
        import winsound # mac don't have this module
        winsound.Beep(2000,1000)
# creat two clock object and let them work
clock1=Clock()
clock1.id="00001"
clock1.price=19
print(f"The id: {clock1.id},the price:{clock1.price}")
clock1.ring()

### 构造方法

- __init__

- 在创建对象的时候，会自动执行

- 会将参数自动传递给__init__变量使用

### 其他内置方法

- __str__

	- 字符串

- __lt__

	- 小于、大于符号比较

- __le__

	- 小于等于、大于等于符号比较

- __eq__

	- ==符号比较

## 封装

### 私有成员

- __开头的成员变量以及成员方法

- 私有方法无法 直接被类对象使用

- 私有变量无法赋值，也无法获取值

### 注意⚠️： 私有成员无法被类对象使用，但是**可以被其他成员使用**，也就是说私有成员可以在内部使用，但是没法到类对象那里使用

## 继承

### 单继承

- 一个子类继承一个父类

	- class 类名（父类名）：
	类内容体

- 在父类中声明过的函数

### 多继承

- 一个子类继承多个父类

	- pass是占位语句，用来保证函数或定义的完整，表示无内容，空的意思

### 复写父类成员方法

- 子类继承父类的成员属性和成员方法，如果对其“不满意”可以进行复写，调用时会显示新内容

### 在子类中调用父类成员

- 直接调用

	- 使用成员变量：父类名.成员变量

使用成员方法：父类名.成员方法(self)

- super()

	- 使用成员变量：super().成员变量

使用成员方法：super().成员方法()

## 多态

### 多种状态，即完成某个行为时，使用不同的对象会得到不同的状态

### 以父类做声明定义；以子类做实际工作

### 配合多态，完成抽象的父类设计以及具体的子类实现

